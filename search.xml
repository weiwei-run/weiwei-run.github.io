<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【每天学点算法系列】单调栈</title>
    <url>/2020/10/28/MonotonousStack/</url>
    <content><![CDATA[<p>一串神秘代码“53124”开启了单调栈的进阶…</p>
<a id="more"></a>

<p><img src="/2020/10/28/MonotonousStack/MonotonousStack1.png" alt="erchashu"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>【Depix】马赛克图片处理</title>
    <url>/2021/01/04/Mosaic/</url>
    <content><![CDATA[<p>朋友在微信圈发了一张图，分享了2020年初立下的flag，不过有部分内容还打码了，可能是不想让人家看到她在想啥。记得早些时候关注过Depix项目，想着是不是可以用这个项目来解析朋友在圈里发的马赛克照片呢，于是看了一下…</p>
<a id="more"></a>

<p>本次分析的主角就是github 3天收割7K star的爆款项目Depix，Depix是用于解析打码后的图像，不过首先我们要了解一下马赛克的基本知识。</p>
<blockquote>
<p>马赛克指一种图像（视频）处理手段，此手段将影像特定区域的色阶细节劣化并造成色块打乱的效果，因为这种模糊看上去由一个个的小格子组成，便形象的称这种画面为马赛克。其目的通常是使之无法辨认。</p>
</blockquote>
<blockquote>
<p>马赛克的作用就是为破坏其背后图像的细节！这是不可逆的，后期处理并不能真正恢复马赛克后面图像的原有细节！任何人或软件都不能去掉马赛克让图像真正恢复原来的效果！</p>
</blockquote>
<blockquote>
<p>马赛克不能被还原，现在都是AI通过后台大量的素材库去猜原图可能会是什么样子，然后使用相同的方法去打码，再和打码后的图像进行比对，以此来达到目的；</p>
</blockquote>
<p><strong>结论：目前来说基本上没有任何一种完全有效的技术能去除马赛克，尤其是静态图片。</strong></p>
<h3 id="动手试试"><a href="#动手试试" class="headerlink" title="动手试试"></a>动手试试</h3><p>1、从github上把Depix项目下载下来，按照如下命令跑一遍它给的demo</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python depix.py -p images/testimages/testimage3_pixels.png -s images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png -o output.png</span><br></pre></td></tr></table></figure>

<p>结果发现还是不错的，对比出来的效果基本和docs中描述的一致，原理就是和预先设置好的德布鲁因序列（searchimages）进行匹配，如果一致则猜测原图的字母排列；当然我说的比较简单，中间还有很多细节，不过大体如此；</p>
<p><img src="/2021/01/04/Mosaic/image-20210122084927955.png" alt="image-20210122084927955"></p>
<p><img src="/2021/01/04/Mosaic/Recovering_prototype_latest.png" alt="Recovering_prototype_latest"></p>
<p>好了，然后我拿到了朋友的微信圈分享图，开始尝试Depix是不是可以处理呢？（纯学术研究，图片已经进行了敏感信息处理）</p>
<p><img src="/2021/01/04/Mosaic/image-20210122085358263.png" alt="image-20210122085358263"></p>
<p>看到这张图你就感觉不太可能复原，或者猜出隐藏的内容；</p>
<p>1、Depix就是能用，但是你没有中文的德布鲁因序列图，怎么查？</p>
<p>2、马赛克的风格有明显不同，该图至少用了两种马赛克的打码，不同的马赛克生成格式一致么？</p>
<p>3、原始编辑器是怎样的，如果不能生成和原图一样的背景图，无法使用Depix分析</p>
<p>总之，Depix的原理是好的，值得学习，但是目前为止想要复原或者猜测出这张图的内容，恐怕是不太现实，在此悬赏，如果有人能成功复原我上面给出的这张图，10000￥红包呈上….</p>
<p>参考：</p>
<p>1.<a href="https://zhuanlan.zhihu.com/p/337593391" target="_blank" rel="noopener">AI看透你的小心思</a></p>
<p>2.<a href="https://zhuanlan.zhihu.com/p/158047094" target="_blank" rel="noopener">马赛克到底能不能被消除</a></p>
]]></content>
      <categories>
        <category>github项目</category>
      </categories>
      <tags>
        <tag>马赛克处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【RPM Packaging Guide】</title>
    <url>/2020/08/31/RPMPackagingGuide/</url>
    <content><![CDATA[<p>翻译《RPM Packaging Guide》顺便学习一下~</p>
<a id="more"></a>

<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>RPM 打包指导文档：</p>
<p><strong>准备打包需要的源代码</strong></p>
<p>这部分为没有软件开发背景的人所写，详见：<a href>准备打包需要的软件</a></p>
<p><strong>如何将源码打包成rpm包</strong></p>
<p>这部分介绍将源码打包成rpm包，详见：<a href>打包软件</a></p>
<p><strong>高级打包技巧</strong></p>
<p>这部分提供给需要在复杂场景打包的人员作为参考材料，详见：<a href>高级用法</a></p>
<h2 id="PDF-版本"><a href="#PDF-版本" class="headerlink" title="PDF 版本"></a>PDF 版本</h2><p>你可以在<a href="https://rpm-packaging-guide.github.io/rpm-packaging-guide.pdf" target="_blank" rel="noopener">这里</a>下载文档PDF版本 </p>
<h2 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h2><p>本文使用如下规范：</p>
<ul>
<li><p>命令输入以及文本文件的内容，包括源代码以块的方式排列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree ~&#x2F;rpmbuild&#x2F;</span><br><span class="line">&#x2F;home&#x2F;user&#x2F;rpmbuild&#x2F;</span><br><span class="line">|-- BUILD</span><br><span class="line">|-- RPMS</span><br><span class="line"></span><br><span class="line">[command output trimmed]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name:           bello</span><br><span class="line">Version:</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:</span><br><span class="line"></span><br><span class="line">[file contents trimmed]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>著作翻译</category>
      </categories>
      <tags>
        <tag>rpm打包</tag>
      </tags>
  </entry>
  <entry>
    <title>【每天学点算法系列】morris遍历</title>
    <url>/2020/09/24/algorithm-leetcode501/</url>
    <content><![CDATA[<p>二叉树的遍历通常O(n)的时间复杂度与O(logn)的空间复杂度，而<strong>morris</strong>遍历实现了O(n)的时间复杂度和O(1)的空间复杂度…</p>
<a id="more"></a>

<h3 id="morris遍历的原理"><a href="#morris遍历的原理" class="headerlink" title="morris遍历的原理"></a>morris遍历的原理</h3><blockquote>
<p>对于没有左子树的节点只达到一次，对于有左子树的节点会到达两次；</p>
</blockquote>
<h3 id="morris遍历的实现原则"><a href="#morris遍历的实现原则" class="headerlink" title="morris遍历的实现原则"></a>morris遍历的实现原则</h3><p>记当前节点为cur</p>
<ol>
<li>如果cur无左子树，cur右移（cur = cur.right）;</li>
<li>如果cur有左子树，找到cur左子树最右的节点，记做mostright；<ul>
<li>如果mostright的right指针为空，则将其指向cur（mostright.right = cur），cur左移（cur = cur.left）;</li>
<li>如果mostright的right指针指向cur，则将其置为空（mostright.right = null），cur右移（cur = cur.right）;</li>
</ul>
</li>
</ol>
<p>图示：</p>
<p><img src="/2020/09/24/algorithm-leetcode501/show.gif" alt="show"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点和前驱节点</span></span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当cur不为null的时候</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点没有左儿子，就走右儿子</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当前节点有左儿子，那么就要找到当前节点的前驱，就是从它的左儿子，然后一直往右走到底。且 不为当前cur节点</span></span><br><span class="line">                pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果前驱节点的右节点已经被设置，也就是我们设置过线索了，需要将它右孩子重新设置为空，输出当前节点。</span></span><br><span class="line">                <span class="comment">// cur更新为cur.right，因为因为我们走的是cur.left，如果设置过线索，就说明左边都访问过了，要看右边</span></span><br><span class="line">                <span class="keyword">if</span> (pre.right == cur) &#123;</span><br><span class="line">                    list.add(cur.val);</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果是第一次访问该节点，也就是还没有设置线索，要设置线索，它的right即为当前节点，然后我们继续看cur.left，因为左边还没设置</span></span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充思考"><a href="#补充思考" class="headerlink" title="补充思考"></a>补充思考</h3><p>1、为什么morris遍历的空间复杂度为O(1)，而一遍的遍历为O(logN)呢？怎么计算的？</p>
<p>一般二叉树的遍历：</p>
<blockquote>
<ol>
<li><strong>先序遍历</strong>：按照 <code>父节点 -&gt; 左孩子 -&gt; 右孩子</code> 的顺序遍历，与DFS（深度优先搜索）有一定联系；</li>
<li><strong>中序遍历</strong>：按照 <code>左孩子 -&gt; 父节点 -&gt; 右孩子</code> 的顺序遍历。当二叉树为二叉搜索树时，中序遍历返回结果为有序序列，因此也叫顺序遍历；</li>
<li><strong>后序遍历</strong>：按照 <code>左孩子 -&gt; 右孩子 -&gt; 父节点</code> 的顺序遍历。</li>
<li><strong>层次遍历</strong>：从左到右，一层一层遍历整个树，与BFS（广度优先搜索）有一定联系。</li>
</ol>
</blockquote>
<p>比如我们用栈来完成一个二叉树的先序遍历，通常是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;(); <span class="comment">// 利用栈进行临时存储</span></span><br><span class="line">	stack.push(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">		TreeNode node = stack.pop(); <span class="comment">// 取出一个节点，表示开始访问以该节点为根的子树</span></span><br><span class="line">		visit(node); <span class="comment">// 首先访问该节点（先序），之后顺序入栈右子树、左子树</span></span><br><span class="line">		<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">		<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果二叉树的结构如图所示，那么栈的大小只要能容纳两个节点就够了，所以这种方法的空间复杂度与二叉树的深度有关，最好和平均为O(logN)，最坏为O(N);</p>
<p><img src="/2020/09/24/algorithm-leetcode501/erchashu.png" alt="erchashu"></p>
<p>而Morris遍历却不一样，它通过对子节点引用的更改来实现后续节点的保存，所以仅仅通过O(1)的空间复杂度实现了二叉树的遍历（大神就是不一样…）</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>1、<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/xue-xi-yi-xia-morrissuan-fa-by-jerry_nju-2/" target="_blank" rel="noopener">力扣501题解</a></p>
<p>2、<a href="https://ghh3809.github.io/2018/08/06/morris-traversal/" target="_blank" rel="noopener">经典算法小评</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>morris算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【basic-computer-games】games?</title>
    <url>/2021/03/01/basic-computer-games/</url>
    <content><![CDATA[<p>没事闲逛 <a href="https://github.com/trending" target="_blank" rel="noopener">github Trending</a>，这里总是能发现让人眼前一亮的项目，今日star排名No.1的是一个叫<code>basic-computer-games</code> 的项目，看到与游戏相关立刻就有了兴致….</p>
<a id="more"></a>

<p>作者收集了一些《<em>BASIC Computer Games</em>》书中的游戏，用C/JAVA/PYTHON/等语言重写，归档到这个github 项目下，目前已经更新了96个小游戏；我一看，好家伙，1973年的书，比我出生还早20年不止，真的是老古董了，话不多说，先试玩一下;</p>
<h3 id="安装VB"><a href="#安装VB" class="headerlink" title="安装VB"></a>安装VB</h3><p>玩这些个古董游戏就需要古董语言的支持，所以首先装一下VB，MAC下只需要下载一下个包，解压就行了不需要安装；<a href="http://www.vintage-basic.net/download.html" target="_blank" rel="noopener">下载地址</a></p>
<p><img src="/2021/03/01/basic-computer-games/image-20210302001038031.png" alt="image-20210302001038031"></p>
<h3 id="aceyducey-游戏"><a href="#aceyducey-游戏" class="headerlink" title="aceyducey 游戏"></a>aceyducey 游戏</h3><p>下载解压好之后，直接执行<code>vintbas aceyducey.bas</code> 就行运行第一个游戏aceyducey了；vintbas在bin目录下，而aceyducey.bas的游戏源代码可以在github中找到 <a href="https://github.com/coding-horror/basic-computer-games/blob/main/01%20Acey%20Ducey/aceyducey.bas" target="_blank" rel="noopener">源码</a>; </p>
<p><img src="/2021/03/01/basic-computer-games/image-20210302001625743.png" alt="image-20210302001625743"></p>
<p>看样子介绍是个猜牌游戏，系统会随机给你两张牌，你猜下一张随机给出的牌是不是在两者之间，并下注一定的金额；本轮也可以选择放弃，输入0即可轮空，直接进行下一轮；如果猜中则你获胜并赢得下注的奖金，如果猜不中则下注的金额被收回；直到你没钱了，这个游戏就结束了；</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>我玩了几把之后总结了几点：</p>
<p>1、牌的大小顺序是2、3、4、、、JACK、QUEEN、KING、ACE；</p>
<p>2、在两者之间不包括两者，比如7，8；这一轮你永远不可能赢，只能选择轮空，输入0；</p>
<p><img src="/2021/03/01/basic-computer-games/image-20210302002549648.png" alt="image-20210302002549648"></p>
<p>3、牌的数量是无限的，这不是一副扑克牌，因为看代码逻辑每次都是随机生成的牌，没有数量限制；</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">260 </span><span class="keyword">PRINT</span><span class="string">"HERE ARE YOUR NEXT TWO CARDS: "</span></span><br><span class="line"><span class="symbol">270 </span>A=<span class="keyword">INT</span>(<span class="number">14</span>*<span class="keyword">RND</span>(<span class="number">1</span>))+<span class="number">2</span></span><br><span class="line"><span class="symbol">280 </span><span class="keyword">IF</span> A&lt;<span class="number">2</span> <span class="keyword">THEN</span> <span class="number">270</span></span><br><span class="line"><span class="symbol">290 </span><span class="keyword">IF</span> A&gt;<span class="number">14</span> <span class="keyword">THEN</span> <span class="number">270</span></span><br><span class="line"><span class="symbol">300 </span>B=<span class="keyword">INT</span>(<span class="number">14</span>*<span class="keyword">RND</span>(<span class="number">1</span>))+<span class="number">2</span></span><br><span class="line"><span class="symbol">310 </span><span class="keyword">IF</span> B&lt;<span class="number">2</span> <span class="keyword">THEN</span> <span class="number">300</span></span><br><span class="line"><span class="symbol">320 </span><span class="keyword">IF</span> B&gt;<span class="number">14</span> <span class="keyword">THEN</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>很多很多小游戏，等待我去探索，后面遇到有好玩的再说，今天先试水一下…</p>
]]></content>
      <categories>
        <category>github项目</category>
      </categories>
      <tags>
        <tag>games</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android专栏】</title>
    <url>/2021/02/05/AndroidColumn/</url>
    <content><![CDATA[<p>最近在做Iot开发免不了接触到一些Android的技术，所以出个专栏记录一下…</p>
<a id="more"></a>

<h2 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h2><p>从在手机上点击一个应用的图标说起</p>
<p>1、首先点击事件会传递给launcher；Launcher其实也是一个app，它是我们开机之后看到的第一个app，它主要用于显示和管理手机上的其他应用，你也可以自己制作一个launcher，比如：</p>
<p><img src="/2021/02/05/AndroidColumn/WechatIMG3.jpeg" alt="WechatIMG3"></p>
<p>2、点击事件会由launcher构造成一个Intent意图，然后通过startActivity方法传递给ActivityManagerService；AMS是在SystemServer进程中启动的，它比launcher初始化要更早一些；</p>
<p>3、然后AMS通过Process.start方法通知到Zygote进程；Zygote进程比SystemServer进程还要早一些存在；关于进程之间的存在先后顺序参考下图，整个Android系统的启动分为linux kernel的启动和android的启动，linux kernel运行起来之后，Android的第一个程序就是init process，主要是一些配置和解析动作，然后就陷入了等待；</p>
<p>很明显能够看出Zygote进程是先于System Server进程之前启动的，且后者是前者fork出来的进程；</p>
<p><img src="/2021/02/05/AndroidColumn/IMG_4C4BD5625EC8-1.jpeg" alt="IMG_4C4BD5625EC8-1"></p>
<p>4、Zygote收到AMS的通知后会fork一个新的进程，而新的进程会从新启应用的ActivityThread开始运行，加载app，创建一个activity对象，这些都是在ActivityThread的mainLoop方法中执行的，然后ActivityThread就陷入了循环；</p>
<p>5、最后ActivityManagerService回调上一步创建activity对象的生命周期方法，onCreate、onStart、onResume然后你就能看到新启应用的页面啦，实际上还有很多细节，不过大致流程就是这样。</p>
<p><img src="/2021/02/05/AndroidColumn/IMG_4611D38DE043-1.jpeg" alt="IMG_4611D38DE043-1"></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>1、apk是由什么组成的？</p>
<p><img src="/2021/02/05/AndroidColumn/image-20210205072610547.png" alt="image-20210205072610547"></p>
<p>找了一个Google浏览器的安装包，解压缩可以看到有AndroidManifest.xml、assets文件夹、dex文件、lib文件夹、META-INF文件夹、res文件夹、一个arsc文件和一个sha256文件；</p>
<ul>
<li><p>AndroidManifest.xml：每个应用都必定会有一个AndroidManifest.xml，它描述了应用的名字、版本、权限、引用的库文件等；</p>
</li>
<li><p>assets文件夹：里面包含了一些适配不同语言相关的文件，还有一些版本描述的文件，有些apk可能没有assets文件夹，这个目录不是apk所必须的；<img src="/2021/02/05/AndroidColumn/image-20210205073023194.png" alt="image-20210205073023194"></p>
</li>
<li><p>dex文件：apk都会有，这些dex就是java或者kotlin编译之后生成的二进制文件；</p>
</li>
<li><p>lib文件夹：存放了一些Jni代码编译生成后的so文件，动态库文件；类似于window的dll文件；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.o 就相当于windows里的obj文件 ，一个.c或.cpp文件对应一个.o文件</span><br><span class="line">.a 是好多个.o合在一起,用于静态连接 ，即STATIC mode，多个.a可以链接生成一个exe的可执行文件</span><br><span class="line">.so 是shared object,用于动态连接的,和windows的dll差不多，使用时才载入</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/05/AndroidColumn/image-20210205073348914.png" alt="image-20210205073348914"></p>
</li>
<li><p>META-INF文件夹:存放的是签名信息，用来保证apk包的完整性和系统的安全;</p>
</li>
<li><p>res文件夹:存放apk用到的资源文件，如：图标，颜色定义等；</p>
<p><img src="/2021/02/05/AndroidColumn/image-20210205073855388.png" alt="image-20210205073855388"></p>
</li>
<li><p>arsc文件：Android编译后生成的产物，主要是用来建立资源映射关系；</p>
</li>
<li><p>sha256文件：校验相关的，一般apk包里也没有；</p>
</li>
</ul>
<h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><ul>
<li>Activity 包含用户界面的组件，主要用于和用户进行交互；</li>
<li>ContentProvider 用于在不同的应用程序之间实现数据共享功能；</li>
<li>Service 实现程序后台运行的解决方案，非常适合那些不需要和用户交互而且还要求长期运行的任务；</li>
<li>BroadcastReceiver Android中的广播机制；</li>
</ul>
<p>四大组件都需要在AndroidManifest注册才能起作用；</p>
<h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p><img src="/2021/02/05/AndroidColumn/IMG_C6B5DC689770-1.jpeg" alt="IMG_C6B5DC689770-1"></p>
<p>1、比如一个activity正在处于界面能与用户交互，突然弹出来一个提醒对话框，抢走了之前activity的焦点，但是并没有完全将其遮蔽，那么前一个activity的状态转移是怎样的？</p>
<p>onResume(能与用户交互)—&gt;onPause(由于弹出提醒对话框被夺走了焦点)</p>
<ul>
<li>如果此时用户X掉了对话框，切换回了之前的界面，那么应该走到onResume；</li>
<li>如果此时用户放大的对话框，导致activity完全不可见，那么应该走到onStop；</li>
</ul>
<h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>ContentProvider提供了应用程序之间共享数据的方法；应用程序通过ContentProvider访问数据而不需要关心数据具体存储及访问过程，这样既提高了数据的访问效率，同时也保护了数据；</p>
<p><img src="/2021/02/05/AndroidColumn/IMG_1FD13F738572-1.jpeg" alt="IMG_1FD13F738572-1"></p>
<p>1、补充一个知识点：URL与URI的区别</p>
<ul>
<li>URL是标示资源的物理位置，相当于文件的路径，如<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li>
<li>URI则是标示资源的逻辑位置，并不提供资源的具体位置，如content://contract/people</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service是Android中实现程序后台运行的解决方案。但是服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程，当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。</p>
<h3 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h3><p>首先和许多其他的GUI库一样，Android的UI也是线程不安全的。如果想要更新应用程序中的UI元素，则必须在主线程中进行，否则就会出现异常。</p>
<p><img src="/2021/02/05/AndroidColumn/image-20210214072108173.png" alt="image-20210214072108173"></p>
<p>比如，直接在子线程中进行更新UI的操作，程序就会异常停止报“CalledFromWrongThreadException”；有些时候我们需要根据子线程的执行结果来更新相应的UI控件，那么应该怎么操作呢？Android的异步消息处理机制完美解决了这个问题，子线程中构造一个message对象，并通过handler的sendMessage方法将该对象发送出去，那么Handler就会收到这条消息，并在handleMessage方法中进行处理；而handleMessage方法中的代码就是在主线程中运行的，所以不会有上面的CalledFromWrongThreadException；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> UPDATE_TEXT:</span><br><span class="line">                    <span class="comment">// 在这里可以进行UI操作</span></span><br><span class="line">                    text.setText(<span class="string">"Nice to meet you"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/02/05/AndroidColumn/image-20210214072805210.png" alt="image-20210214072805210"></p>
<h3 id="异步消息处理机制详解"><a href="#异步消息处理机制详解" class="headerlink" title="异步消息处理机制详解"></a>异步消息处理机制详解</h3><p>Android中的异步消息处理主要由四部分组成：</p>
<ul>
<li>Message: 用于线程之间传递消息，what子段，arg1、arg2、obj字段；</li>
<li>Handler: 消息处理者，发送消息一般使用Handler的sendMessage方法，而发出的消息经过一系列辗转，最终会传递到Handler的handleMessage方法中；</li>
<li>MessageQueue: 用于存放所有通过Handler发送的消息，每个线程中只会有一个MessageQueue对象；</li>
<li>Looper: 每个线程中的MessageQueue的管家，调用Looper的loop方法后，就会进入到一个无限的循环当中，然后每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage方法中。每个线程也只会有一个Looper对象；</li>
</ul>
<p><img src="/2021/02/05/AndroidColumn/IMG_D6D1AC18EFAE-1.png" alt="IMG_D6D1AC18EFAE-1"></p>
<p>1、首先需要在主线程中创建一个Handler对象，并重写handleMessage方法；</p>
<p>2、当子线程中的UI需要更新时，创建一个Message对象，并且通过Handler对象调用sendMessage方法，将这条消息发送出去；</p>
<p>3、这条消息就被添加到MessageQueue队列中等待被处理，而Looper则会一直尝试从MessageQueue中取出待处理的消息，最后发回给Handler的handlerMessage方法中。</p>
<p>4、由于Handler是在主线程中创建的，所以此时handleMessage方法中的代码也会在主线程中运行；</p>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p>广播：标准广播、有序广播</p>
<p>注册方式：动态注册、静态注册</p>
<h3 id="如何创建一个广播接收器"><a href="#如何创建一个广播接收器" class="headerlink" title="如何创建一个广播接收器"></a>如何创建一个广播接收器</h3><p>只需要新建一个类，让它继承BroadcastReceiver，并重写父类的onReceive() 方法。这样当有广播到来时，onReceive方法就会得到执行，具体处理逻辑可以写在这个方法里；比如一个监听网络变化的程序：</p>
<p>1、创建一个NetworkChangeReceiver类继承BroadcastReceiver</p>
<p>2、重写onReceive方法处理逻辑就是弹出一个toast提示；</p>
<p>3、创建一个IntentFilter对象实例，添加对网络状态变化的广播进行监听（当网络发生变化时，系统会发出一条值为android.net.conn.CONNECTIVITY_CHANGE的广播）</p>
<p>4、注册广播registerReceiver传入两个参数，一个是BroadcastReceiver实例，一个是InterFilter实例；</p>
<p>5、这样就写完了，当网络状态发生变化时，系统会发出一条广播，而这条广播被NetworkChangeReceiver监听到从而执行onReceive方法，弹出toast提示；</p>
<p><img src="/2021/02/05/AndroidColumn/image-20210222072241380.png" alt="image-20210222072241380"></p>
<h3 id="静态注册实现开机启动"><a href="#静态注册实现开机启动" class="headerlink" title="静态注册实现开机启动"></a>静态注册实现开机启动</h3><p>以上是动态注册的方法，写在了onCreate方法中，很明显只有应用程序启动之后注册语句才能够执行，但是如果我想要程序还没有启动就能接收到广播呢？比如我想要一个应用程序监听到开机的广播后能自动启动，这种情况就需要用到<strong>静态注册</strong>的方法了；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">".BootCompleteReceiver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如定义一个BootCompleteReceiver来实现监听开机广播，直接在AndroidMinifest.xml中这样注册，然后就可以在BootCompleteReceiver的onReceive方法中实现监听到开机广播后你想要的逻辑了；</p>
<h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><p>前面的广播都是系统发的，我们只是实现了广播监听；现在我们来自己发送一个广播，然后自己监听发送的广播；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>静态方法注册监听，然后在代码中发送自定义的广播；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button = findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span>);</span><br><span class="line">                sendBroadcast(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><p>相比于发送标准广播，只需要修改发送方式为sendOrderedBroadcast即可；比如: <code>sendOrderedBroadcast(intent, null)</code>, 第一个参数还是和之前一样，第二个参数表示与权限相关的字符串；</p>
<p>有序广播可以通过设置接收器的优先级来决定由哪个接收器先接到广播</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以在onReceive方法中调用<code>abortBroadcast</code>进行广播截断，这样后面的接收器就收不到这条广播了；</p>
<h3 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h3><ul>
<li><strong>只在程序内部使用，不用担心机密数据泄露</strong></li>
<li><strong>其他的程序无法将广播发送到我们程序内部，不需要担心会有安全漏洞</strong></li>
<li><strong>相比全局广播更高效</strong></li>
</ul>
<p>本地广播其实相比于之前所示改动点有两个：</p>
<ol>
<li><p>发送广播的方式，使用LocalBroadcastManager.sendBroadcast发送；如：<code>LocalBroadcastManager.sendBroadcast(intent);</code></p>
</li>
<li><p>注册本地监听器的方式，使用LocalBroadcastManager.registerReceiver注册，如：<code>LocalBroadcastManager.registerReceiver(localReceiver, intentFilter);</code></p>
</li>
</ol>
<p>最后要注意一点：本地广播是无法通过静态注册的方式来接收的，这也可以理解。因为静态注册本身是为了让程序在未启动的时候也能接收广播，而发送本地广播时，我们的程序肯定是已经启动了的，所以也不需要使用静态注册的能力；</p>
<h2 id="数据存储解决方案"><a href="#数据存储解决方案" class="headerlink" title="数据存储解决方案"></a>数据存储解决方案</h2><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>1、项目下的build.gradle与app/build.gradle分别是什么文件？有什么作用？</p>
<p>首先项目下的build.gradle是项目的全局构建脚本，通常这个文件是不需要修改的；repositories闭包一般都会声明google() 和jcenter()，分别对应google的扩展依赖库和jcenter三方开源库；声明了这两行的配置之后，就可以在项目中轻松引用任何google和jenter仓库中的依赖库了；</p>
<p>然后dependencies闭包中使用classpath声明了两个插件：一个Gradle插件和一个Kotlin插件；</p>
<p>gradle并不是专门为构建android项目开发的，Java、c++等多种项目也可以使用Gradle来构建，因此如果想使用它来构建Android项目，则需要声明这个插件；后面的2.3.3是插件的版本号，通常要和当前AndroidStudio的版本是对应的；另一个则表示kontlin插件，如果是Java版本的Android项目则不需要声明；</p>
<p><img src="/2021/02/05/AndroidColumn/image-20210729073451961.png" alt="image-20210729073451961"></p>
<p>app模块下的build.gradle是模块的构建脚本，这个文件中会指定很多项目构建相关的配置；</p>
<p>com.android.application表示这是个应用模块而不是库模块，kotlin-android表示插件，如果是kotlin开发那么这个是必须要有的；applicationId是每个应用的唯一标识符，绝对不能重复，默认会使用在创建项目时指定的包名。testInstrumentationRunner 在当前项目中启用JUnit测试，可以为当前项目编写测试用例保证功能的正确性和稳定性；</p>
<p>buildTypes闭包用于指定生成安装文件的相关配置，通常只会有两个子闭包：debug和release。debug用于生成指定测试版安装文件的配置，release用于生成正式版安装文件的配置；另外debug闭包是可以忽略不写的；minifyEnabled用于指定是否对项目的代码进行混淆，proguardFiles用于指定混淆时使用的规则文件；</p>
<p>最后的dependencies闭包指定当前项目所有的依赖关系；通常Android Studio项目一共有3种依赖方式：</p>
<ul>
<li>本地依赖（比如第一行的fileTree 表示将libs目录下的所有.jar后缀的文件都添加到项目的构建路径中）</li>
<li>库依赖（基本格式是implementation project后面加上要依赖的库的名称）</li>
<li>远程依赖（androidx.appcompat:appcompat:1.1.0，分别表示域名，工程名，版本号）</li>
</ul>
<p><img src="/2021/02/05/AndroidColumn/Screen-Shot-2021-07-27-at-22.45.13.png" alt="Screen Shot 2021-07-27 at 22.45.13"></p>
<p>2、java的文件流详细解析；</p>
<p>参考文档：</p>
<ol>
<li><a href="https://developer.android.google.cn/guide?hl=zh_cn" target="_blank" rel="noopener">Android Developers</a></li>
<li><a href="https://www.cnblogs.com/lao-liang/p/5067312.html" target="_blank" rel="noopener">Android系统启动分析</a></li>
<li>《第一行代码》</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android专栏</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hello World】</title>
    <url>/2020/07/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>【每天学点算法系列】链表与环的探究</title>
    <url>/2020/10/26/listAndCircle/</url>
    <content><![CDATA[<p>最近看了一点 Floyd cycle detection（弗洛伊德判圈算法），觉得有点意思，特此整理了一下…</p>
<a id="more"></a>

<p><strong>关于一个链表与环可能会遇到的问题</strong>：</p>
<blockquote>
<ol>
<li>判断一个链表是否有环？</li>
<li>找出环的起始位置；</li>
<li>找出环的大小；</li>
<li>求链表的长度：起始位置+环的大小</li>
<li>如果存在环，求出环上任意一个节点最远的点</li>
<li>如何判断两个无环链表是否相交</li>
<li>如果相交，求出第一个相交的点；</li>
</ol>
</blockquote>
<h3 id="判断一个链表是否有环"><a href="#判断一个链表是否有环" class="headerlink" title="判断一个链表是否有环"></a>判断一个链表是否有环</h3><p>快慢指针算法</p>
<p>// loading…</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>环</tag>
      </tags>
  </entry>
  <entry>
    <title>【multi-agent-simulation】社会力模型演示</title>
    <url>/2021/01/31/multi-agent-simulation/</url>
    <content><![CDATA[<p>近日有幸接触到robot跟随方面的研究，而跟随方向的论文大都提到了Social force model【社会力模型】，这个概念最早可追溯到Dirk Helbing在1995年的论文[Social force model for pedestrian dynamics]….</p>
<a id="more"></a>

<h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p><img src="/2021/01/31/multi-agent-simulation/IMG_0010.jpg" alt="IMG_0010"></p>
<p>大致就是我上面描述的这个意思，核心思想就是把微观世界中的相互作用力引入到宏观世界，比如人类社会；一个人如果想要跟随另一个人应该怎么运动才能避免碰撞到周围的人，同时又能很好地跟随目标，社会力模型提供了一个思路。</p>
<p>注：社会力模型在不同的论文中有很多变化，考虑的维度也不一样如果你认为我说的不对，那么以你的为准；</p>
<h3 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a>github项目</h3><p><a href="https://github.com/my-HenryS/multi-agent-simulation" target="_blank" rel="noopener">multi-agent-simulation</a>是github上一个开源项目，时间比较久了博主后面基本没怎么维护，不过拿来跑跑，看一下效果还是可以的；配置好maven，JDK，直接导入，运行SimulationPanelMain；</p>
<p>项目具体描述参考readme文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">欲开始运行仿真请打开app包，并运行其中的一个Main程序。Gui内的SimulationPanelMain是可视化的仿真界面，主要用于演示；Console内的TextOutputMain是可以将运行结果以字符串形式输出的Main程序，主要用于输出具体的数据以便实验使用。</span><br><span class="line"></span><br><span class="line">项目分为5个package，分别为app、container、drawer、geom、model</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/31/multi-agent-simulation/ScreenShot2021-02-04at06.54.16.png" alt="Screen Shot 2021-02-04 at 06.54.16"></p>
<p>运行成功之后会出现如下所示，选择Simulation Mode，然后可以选择模拟的场景，比如：ApplicationForSubway</p>
<p><img src="/2021/01/31/multi-agent-simulation/image-20210204065949988.png" alt="image-20210204065949988"></p>
<p>目前只看到了subway和Cross Flow场景是可以正常run起来的，其他的场景估计要加载配置，不过效果就是这样；相关的算法，节点数量，障碍物设置都是可以自己调整的，对于整个社会力模型的认识是有帮助的；如果做跟随路径规划，也可以在模型中先跑一跑看一下效果；</p>
<p><img src="/2021/01/31/multi-agent-simulation/2021-02-0407.05.50.gif" alt="2021-02-04 07.05.50"></p>
<p>好了本次的github项目分享就到这里，后面看到有趣的好玩的github项目，会继续发出来让更多的人知道…</p>
]]></content>
      <categories>
        <category>github项目</category>
      </categories>
      <tags>
        <tag>社会力模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【2020科学上网日记】</title>
    <url>/2020/12/09/scienceOnline2020/</url>
    <content><![CDATA[<p>那一天，人类回想起了，曾经被那堵墙支配的恐惧，以及被囚禁在鸟笼中的屈辱…</p>
<p>—-节选自《2020科学上网日记》</p>
<a id="more"></a>

<p>很久很久以前，那个时候是可以直接访问Google、Facebook、Twitter、Instagram等国外网站的。</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at21.41.58.png" alt="ScreenShot2020-12-09at21.41.58"></p>
<p>突然有一天，一堵名为GFW（Great Firewall）的大墙挡在了中间，从此生活便少了诸多色彩。</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at21.50.13.png" alt="Screen Shot 2020-12-09 at 21.50.13"></p>
<p>终于有一天，一个叫SSH Server的东西出现了，它改变了我的世界。它生来就与众不同，我们访问它可以不经过GFW，而他可以访问外面的世界不受GFW的影响。如此我们之后就可以请他代替我们访问一些被GFW墙掉的网站，然后再将内容发给我们。</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at21.51.20.png" alt="Screen Shot 2020-12-09 at 21.51.20"></p>
<p>但是，GFW不甘心这种东西的存在，而ssh本身的特征是明显的，GFW便可以分析连接特征去搞搞小破坏，干扰我们的开心生活。于是ss便出现了。</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at21.51.59.png" alt="Screen Shot 2020-12-09 at 21.51.59"></p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>环境工具：Vultr + v2ray</p>
<h4 id="一、首先买一台墙外的服务器，作为SS-Server，推荐选择Vultr。"><a href="#一、首先买一台墙外的服务器，作为SS-Server，推荐选择Vultr。" class="headerlink" title="一、首先买一台墙外的服务器，作为SS Server，推荐选择Vultr。"></a>一、首先买一台墙外的服务器，作为SS Server，推荐选择Vultr。</h4><blockquote>
<p>有很多国外服务商，像aws、google、vultr、搬瓦工，等等。aws可以免费一年，google也类似，但是国外的网站可能不符合咱的操作习惯，很多用起来很麻烦，对小白太累，而且aws每个月只免费1G流量，他们还需要信用卡绑定，有些学生又没有信用卡。所以我们可能会选择搬瓦工或者vultr这种操作简单，支持支付宝支付的商家。就我来说，我喜欢vultr，按小时计费，可以随时删除服务器，应对ip被封的情况，而且价格相对便宜，网站简洁，操作简单，支持支付宝微信支付。搬瓦工相对vultr要便宜一点，但是一般是月付或者年付，万一被封ip，可能就亏了，但是对于买来还有其他用途的人来说，搬瓦工也是个不错的选择哦</p>
</blockquote>
<p>访问<a href="https://www.vultr.com/" target="_blank" rel="noopener">Vultr官网</a>注册账号，验证邮箱</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at21.57.27.png" alt="Screen Shot 2020-12-09 at 21.57.27"></p>
<p>账户没钱记得存点钱，可以使用支付宝</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.02.38.png" alt="Screen Shot 2020-12-09 at 22.02.38"></p>
<p>选择Products，购买一台服务器，推荐（Tokyo - Ubuntu 18.04 X64 - $5/mo）</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at21.59.46.png" alt="Screen Shot 2020-12-09 at 21.59.46"></p>
<p>Deploy Now完成后就可以看到创建的实例了，比如我的</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.05.17.png" alt="Screen Shot 2020-12-09 at 22.05.17"></p>
<p>MAC 可以使用ShellCraft连接服务器，Host是你的服务器IP，端口22不变，User name是root，Password 服务器详情中查看。</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.08.07.png" alt="Screen Shot 2020-12-09 at 22.08.07"></p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.09.36.png" alt="Screen Shot 2020-12-09 at 22.09.36"></p>
<p>连接成功之后如下：</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.11.25.png" alt="Screen Shot 2020-12-09 at 22.11.25"></p>
<h4 id="二、配置SS-Server"><a href="#二、配置SS-Server" class="headerlink" title="二、配置SS Server"></a>二、配置SS Server</h4><p>服务器买了当然要配置一下，不然怎么在墙外接收你的request呢，推荐使用V2ray因为更稳定，一键安装：</p>
<p>将以下命令复制到你已连接的服务器命令行中，然后就是一步一步下一步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure>

<p>选择1，按回车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1. 安装</span><br><span class="line"> 2. 卸载</span><br><span class="line">请选择 [1-2]:1</span><br></pre></td></tr></table></figure>

<p>用默认的tcp就行，直接回车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请选择 V2Ray 传输协议 [1-32]</span><br><span class="line">  1. TCP</span><br><span class="line">  2. TCP_HTTP</span><br><span class="line">  3. WebSocket</span><br><span class="line">  4. WebSocket + TLS</span><br><span class="line">  5. HTTP&#x2F;2</span><br><span class="line">  6. mKCP</span><br><span class="line">  7. mKCP_utp</span><br><span class="line">  8. mKCP_srtp</span><br><span class="line">  9. mKCP_wechat-video</span><br><span class="line"> 10. mKCP_dtls</span><br><span class="line"> 11. mKCP_wireguard</span><br><span class="line"> 12. QUIC</span><br><span class="line"> 13. QUIC_utp</span><br><span class="line"> 14. QUIC_srtp</span><br><span class="line"> 15. QUIC_wechat-video</span><br><span class="line"> 16. QUIC_dtls</span><br><span class="line"> 17. QUIC_wireguard</span><br><span class="line"> 18. TCP_dynamicPort</span><br><span class="line"> 19. TCP_HTTP_dynamicPort</span><br><span class="line"> 20. WebSocket_dynamicPort</span><br><span class="line"> 21. mKCP_dynamicPort</span><br><span class="line"> 22. mKCP_utp_dynamicPort</span><br><span class="line"> 23. mKCP_srtp_dynamicPort</span><br><span class="line"> 24. mKCP_wechat-video_dynamicPort</span><br><span class="line"> 25. mKCP_dtls_dynamicPort</span><br><span class="line"> 26. mKCP_wireguard_dynamicPort</span><br><span class="line"> 27. QUIC_dynamicPort</span><br><span class="line"> 28. QUIC_utp_dynamicPort</span><br><span class="line"> 29. QUIC_srtp_dynamicPort</span><br><span class="line"> 30. QUIC_wechat-video_dynamicPort</span><br><span class="line"> 31. QUIC_dtls_dynamicPort</span><br><span class="line"> 32. QUIC_wireguard_dynamicPort</span><br><span class="line">备注1: 含有 [dynamicPort] 的即启用动态端口..</span><br><span class="line">备注2: [utp | srtp | wechat-video | dtls | wireguard] 分别伪装成 [BT下载 | 视频通话 | 微信视频通话 | DTLS 1.2 数据包 | WireGuard 数据包]</span><br><span class="line">(默认协议: TCP):</span><br></pre></td></tr></table></figure>

<p>端口随便写一个，范围1025到65535，也可以选择默认，直接回车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入 V2Ray 端口 [1-65535]</span><br><span class="line">(默认端口: 22681):</span><br></pre></td></tr></table></figure>

<p>这个也不知道真影响假影响，姑且相信他，使用默认，直接回车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是否开启广告拦截(会影响性能) [Y&#x2F;N]</span><br><span class="line">(默认 [N]):</span><br></pre></td></tr></table></figure>

<p>是不是顺便把ss服务也装了，这个就随便你了，我感觉用了v2ray也没必要再搭ss，毕竟s’s很容易被封，所以保持默认，回车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是否配置 Shadowsocks [Y&#x2F;N]</span><br><span class="line">(默认 [N]):</span><br></pre></td></tr></table></figure>

<p>会让你确认一下信息，确认无误，按回车</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------- 安装信息 -------------</span><br><span class="line"> V2Ray 传输协议 &#x3D; TCP</span><br><span class="line"> V2Ray 端口 &#x3D; 22681</span><br><span class="line"> 是否配置 Shadowsocks &#x3D; 未配置</span><br><span class="line">---------- END -------------</span><br><span class="line">按 Enter 回车键 继续....或按 Ctrl + C 取消.</span><br></pre></td></tr></table></figure>

<p>然后，就是等…</p>
<p>安装完成，最后会提示你连接配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------- V2Ray 配置信息 -------------</span><br><span class="line"> 地址 (Address) &#x3D; 152.89.208.146</span><br><span class="line"> 端口 (Port) &#x3D; 47283</span><br><span class="line"> 用户ID (User ID &#x2F; UUID) &#x3D; ed0b4117-0f5a-41e9-a732-96bdaf343d23</span><br><span class="line"> 额外ID (Alter Id) &#x3D; 233</span><br><span class="line"> 传输协议 (Network) &#x3D; tcp</span><br><span class="line"> 伪装类型 (header type) &#x3D; none</span><br><span class="line">---------- END -------------</span><br></pre></td></tr></table></figure>

<p>也可以通过命令<code>v2ray url</code> 和 <code>v2ray qr</code> 获取v2ray url和v2ray QRCode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ONEVPS190911085532:~# v2ray url</span><br><span class="line">---------- V2Ray vmess URL &#x2F; V2RayNG v0.4.1+ &#x2F; V2RayN v2.1+ &#x2F; 仅适合部分客户端 -------------</span><br><span class="line">vmess:&#x2F;&#x2F;ewoidiI6ICIyIiwKInBzIjogIjIzM3YyLmNvbV8xNTIuODkuMjA4LjE0NiIsCiJhZGQiOiAiMTUyLjg5LjIwOC4xNDYiLAoicG9ydCI6ICI0NzI4MyIsCiJpZCI6ICJlZDBiNDExNy0wZjVhLTQxZTktYTczMi05NmJkYWYzNDNkMjMiLAoiYWlkIjogIjIzMyIsCiJuZXQiOiAidGNwIiwKInR5cGUiOiAibm9uZSIsCiJob3N0IjogIiIsCiJwYXRoIjogIiIsCiJ0bHMiOiAiIgp9Cg&#x3D;&#x3D;</span><br><span class="line">root@ONEVPS190911085532:~# v2ray qr</span><br><span class="line">---------- V2Ray 二维码链接 适用于 V2RayNG v0.4.1+ &#x2F; Kitsunebi -------------</span><br><span class="line">https:&#x2F;&#x2F;233boy.github.io&#x2F;tools&#x2F;qr.html#vmess:&#x2F;&#x2F;ewoidiI6ICIyIiwKInBzIjogIjIzM3YyLmNvbV8xNTIuODkuMjA4LjE0NiIsCiJhZGQiOiAiMTUyLjg5LjIwOC4xNDYiLAoicG9ydCI6ICI0NzI4MyIsCiJpZCI6ICJlZDBiNDExNy0wZjVhLTQxZTktYTczMi05NmJkYWYzNDNkMjMiLAoiYWlkIjogIjIzMyIsCiJuZXQiOiAidGNwIiwKInR5cGUiOiAibm9uZSIsCiJob3N0IjogIiIsCiJwYXRoIjogIiIsCiJ0bHMiOiAiIgp9Cg&#x3D;&#x3D;</span><br><span class="line"> 友情提醒: 请务必核对扫码结果 (V2RayNG 除外)</span><br></pre></td></tr></table></figure>

<h4 id="三、配置客户端"><a href="#三、配置客户端" class="headerlink" title="三、配置客户端"></a>三、配置客户端</h4><p>既然SS Server 配置好了，那就搞SS Local了，如果你用mac OS就下个V2RayX，如果你用Android手机就下个v2rayNG</p>
<p><a href="https://tlanyan.me/v2ray-clients-download/" target="_blank" rel="noopener">V2Ray客户端下载地址</a></p>
<p>比如MAC：打开客户端，选择Config，配置上一步生成的Address、Port、User ID、Alter Id即可，也可以通过导入url来自动配置；</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.22.14.png" alt="Screen Shot 2020-12-09 at 22.22.14"></p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.23.07.png" alt="Screen Shot 2020-12-09 at 22.23.07"></p>
<p>配置完成后，选择PAC Mode, 然后点击load core就是开启了服务；</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.27.02.png" alt="Screen Shot 2020-12-09 at 22.27.02"></p>
<p>然后就可以打开谷歌浏览器看下youtube是不是可以正常访问啦， da’gong’gao’cheng</p>
<p><img src="/2020/12/09/scienceOnline2020/ScreenShot2020-12-09at22.28.54.png" alt="Screen Shot 2020-12-09 at 22.28.54"></p>
<p>安卓手机或者其他设备同理，只需要安装V2Ray客户端，配置好即可，记得给服务器续费…</p>
<h5 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h5><p>1、<a href="https://viencoding.com/article/114" target="_blank" rel="noopener">Vultr注册并购买服务器搭VPN</a></p>
<p>2、<a href="https://viencoding.com/article/207" target="_blank" rel="noopener">如何搭建v2ray，放弃使用ss和ssr</a></p>
<p>3、<a href="https://viencoding.com/article/155" target="_blank" rel="noopener">搭梯子</a></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>【The Clean Coder】</title>
    <url>/2021/02/15/theCleanCoder/</url>
    <content><![CDATA[<p>花了大概2个小时，读完了Bob大叔的这本《代码整洁之道——程序员的职业素养》有种斜躺在沙发上整日阅读叔本华的感觉….</p>
<a id="more"></a>

<p>书中很多细节的表述直抵内心，比如妻子怀胎两月时自己被公司开除的羞愧；两周垒完一个应用+后台+存储时的狼狈；自己幼年参照手册完成逻辑门的欢呼雀跃～这些情节总是能对照自身找到共鸣。大学时为了加入acm班绞尽脑汁第一个写出找素数程序，还被同学夸奖说学得快；面试时作为物联网专业毕业生不知道iot的尴尬以及说不出什么是软件工程的羞愧；工作中技术分享会由于太紧张还有准备不充分被大佬怼得哑口无言… </p>
<p>大学教育其实不能为我们带来职业素养，程序员真正重要的东西往往都是在职业发展中，在工作中，在一个个狼狈不堪的项目中学到的。这本书就像是为你讲述Bob大叔，这么一位人们公认的大神他的成长之路，你会觉得也不过如此，没有什么捷径，都是在辛勤的劳累和思考中获得的，我们也能做到。</p>
<p>书中关于职业素养讲了很多，印象较深的有拒绝。懂得拒绝是职业素养很重要的一点。有时候迫于领导的权威，我们可能会答应，最后交付一堆烂代码，这是极其不负责任的。还有一个人的精力是有限的，如何做好时间管理，不要为了细枝末节浪费了你有限的魔力点数。关于日常要做卡塔练习，因为两个对手干架的时候，最先启动的是肌肉记忆，上层大脑的策略逻辑永远是慢一拍的。还有和团队的协作，工具的使用等等，强烈建议每个有志成为专业程序员的人都能通读一遍，从中受益。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>代码整洁之道</tag>
      </tags>
  </entry>
  <entry>
    <title>【learn Git Branching】</title>
    <url>/2021/02/15/learnGitBranching/</url>
    <content><![CDATA[<p>Git作为程序员必备的技能，有些命令长时间不用就慢慢遗忘了比如<code>rebase -i</code>、<code>branch -f</code>，花了一个小时完了把游戏，强化这些命令…<a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">游戏入口传送门</a></p>
<a id="more"></a>

<p>我已经通关啦，哈哈哈哈…</p>
<p><img src="/2021/02/15/learnGitBranching/image-20210215213758725.png" alt="image-20210215213758725"></p>
<h3 id="玩游戏的过程中又重新回顾的知识点："><a href="#玩游戏的过程中又重新回顾的知识点：" class="headerlink" title="玩游戏的过程中又重新回顾的知识点："></a>玩游戏的过程中又重新回顾的知识点：</h3><p>1、reset和revert的区别：reset是向上移动分支，相当于本地代码的最后一次提交就被抹去了；而revert则是为了撤销上一次的修改，重新提了一笔代码，它是可以直接push到远程分支的；</p>
<p>2、<code>git branch -f main C3</code> 将main分支强制指向某一次提交；</p>
<p>3、<code>git rebase main</code> 找到当前分支与rebase的目的分支的共同节点，将共同节点以下到当前分支的HEAD所有的修改，拷贝到需要rebase的分支上；</p>
<p>4、<code>cherry-pick</code> 将指定的提交，更新到某个分支上；</p>
<h3 id="项目开发过程中可能会遇到的与Git相关的问题"><a href="#项目开发过程中可能会遇到的与Git相关的问题" class="headerlink" title="项目开发过程中可能会遇到的与Git相关的问题"></a>项目开发过程中可能会遇到的与Git相关的问题</h3><p>1、 一个或者几个提交由于种种原因（gerrit超时过期、分支混乱等）无法正常提交合入，有没有一种最原始直接的办法将这一个或几个commit提交合入主干？</p>
<p>最原始的办法当然就是另起一个mr，重新提交；可能之前的commit修改的文件很多，如果手动逐个文件进行更改，那就太离谱了；可以使用git format-patch命令打patch，然后再新的代码仓中应用这个patch即可：</p>
<p><code>git format-patch &lt;r1&gt;...&lt;r2&gt;</code>两个commit及其之间的修改打成一个patch;</p>
<p><code>git format-patch -1 &lt;r1&gt;</code> 单个commit打成一个patch;</p>
<p><code>git format-patch &lt;r1&gt;</code> 从r1到最新代码的变更打成一个patch，不包含r1;</p>
<p><code>git apply --stat 0001-minor-fix.patch</code> 检查patch文件；</p>
<p><code>git apply --check 0001-minor-fix.patch</code> 查看能否应用成功；</p>
<p><code>git am -s &lt; 0001-minor-fix.patch</code> 应用patch;</p>
<p>// loading…</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>1、<a href="https://www.jianshu.com/p/814fb6606734" target="_blank" rel="noopener">Git生成patch和应用patch</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
</search>
